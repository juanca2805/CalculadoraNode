"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.off = exports.on = exports.getBox = void 0;
const methods_1 = __importDefault(require("./methods"));
const ee_1 = __importDefault(require("./ee"));
const modifiers_1 = __importDefault(require("./modifiers"));
const tools_1 = require("./tools");
const links = new Map();
function setHandler(target, prop, value, proxy) {
    const oldValue = target[prop];
    if (oldValue === value)
        return true;
    const link = links.get(target);
    const newValue = getBox(value);
    link[prop] = newValue;
    if (target.__isWatched) {
        ee_1.default.emit(proxy, prop, proxy, prop, 'set', oldValue, newValue);
    }
    return true;
}
function arrGetHandler(target, prop, proxy) {
    const method = methods_1.default[prop] || modifiers_1.default[prop];
    return method
        ? method(target, proxy, getBox)
        : target[prop];
}
function getBox(origin) {
    if (!origin || !tools_1.isObject(origin) || tools_1.isBox(origin)) {
        return origin;
    }
    const isArray = Array.isArray(origin);
    const target = isArray ? [] : {};
    tools_1.setHiddenKey(target, '__isWatched', false);
    tools_1.setHiddenKey(target, '__isBox', true);
    Object.keys(origin).forEach(key => {
        target[key] = getBox(origin[key]);
    });
    const proxy = new Proxy(target, {
        get: isArray
            ? arrGetHandler
            : (...args) => Reflect.get(...args),
        set: setHandler,
        deleteProperty(target, prop) {
            if (!(prop in target))
                return true;
            const oldValue = target[prop];
            delete target[prop];
            if (target.__isWatched) {
                ee_1.default.emit(proxy, prop, proxy, prop, 'delete', oldValue, undefined);
            }
            return true;
        }
    });
    links.set(target, target);
    return proxy;
}
exports.getBox = getBox;
function on(box, prop, handler) {
    if (!prop.includes('.')) {
        const { off, emit } = ee_1.default.on(box, prop, handler);
        return { off, emit };
    }
    const props = prop.split('.');
    let len = props.length - 1;
    const propName = props[len];
    const scopes = [box];
    props.forEach(propName => {
        const localBox = scopes[scopes.length - 1][propName] || {};
        scopes.push(localBox);
    });
    const controllers = [];
    const finalEventController = ee_1.default.on(scopes[len], propName, handler);
    controllers.unshift(finalEventController);
    while (--len >= 0) {
        const localProp = props[len];
        const localScope = scopes[len];
        const n = len + 1;
        const eventController = ee_1.default.on(localScope, localProp, (_, __, ___, oldValue, newValue) => {
            const nextController = controllers[n];
            const currentProp = props[n];
            const nextScope = typeof newValue === 'object' ? newValue : {};
            const prevScope = oldValue && typeof oldValue === 'object' ? oldValue : {};
            const nextValue = nextScope[currentProp];
            const prevValue = prevScope[currentProp];
            nextScope.__isWatched = true;
            nextController.transfer(nextScope);
            nextValue !== prevValue &&
                nextController.emit(nextScope, currentProp, 'set', prevValue, nextValue);
        });
        controllers.unshift(eventController);
    }
    return {
        emit: handler,
        off() {
            controllers.forEach(controller => controller.off());
        }
    };
}
exports.on = on;
exports.off = ee_1.default.off;
